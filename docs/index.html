<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 7.4.0" />
    <title>skeletor API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>



                    <h2>Contents</h2>
                    <ul>
  <li><a href="#what-is-skeletor">What is skeletor?</a></li>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#getting-started">Getting started</a></li>
  <li><a href="#examples">Examples</a></li>
  <li><a href="#gotchas">Gotchas</a></li>
  <li><a href="#benchmarks">Benchmarks</a></li>
  <li><a href="#what-about-algorithm-x">What about algorithm <code>X</code>?</a></li>
  <li><a href="#references">References</a></li>
  <li><a href="#top-level-functions-and-classes">Top-level functions and classes</a></li>
</ul>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Skeleton">Skeleton</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Skeleton.__init__">Skeleton</a>
                        </li>
                        <li>
                                <a class="variable" href="#Skeleton.edges">edges</a>
                        </li>
                        <li>
                                <a class="variable" href="#Skeleton.vertices">vertices</a>
                        </li>
                        <li>
                                <a class="variable" href="#Skeleton.radius">radius</a>
                        </li>
                        <li>
                                <a class="variable" href="#Skeleton.skeleton">skeleton</a>
                        </li>
                        <li>
                                <a class="variable" href="#Skeleton.skel_map">skel_map</a>
                        </li>
                        <li>
                                <a class="function" href="#Skeleton.reindex">reindex</a>
                        </li>
                        <li>
                                <a class="function" href="#Skeleton.copy">copy</a>
                        </li>
                        <li>
                                <a class="function" href="#Skeleton.save_swc">save_swc</a>
                        </li>
                        <li>
                                <a class="function" href="#Skeleton.scene">scene</a>
                        </li>
                        <li>
                                <a class="function" href="#Skeleton.show">show</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#example_mesh">example_mesh</a>
            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
skeletor    </h1>

                        <div class="docstring"><h1 id="what-is-skeletor">What is skeletor?</h1>

<p>Unlike its <a href="https://en.wikipedia.org/wiki/Skeletor">namesake</a>, this <code><a href="">skeletor</a></code>
does not (yet) seek to conquer Eternia but to turn meshes into skeletons.</p>

<p>Before we get started some terminology:</p>

<ul>
<li>a <em>mesh</em> is something that consists of <em>vertices</em> and <em>faces</em></li>
<li>a <em>skeleton</em> is a (hierarchical) tree-like structure consisting of <em>vertices</em>
(also called <em>nodes</em>) and <em>edges</em> that connect them</li>
</ul>

<p>Skeletons are useful for a range of reasons. For example:</p>

<ol>
<li>Typically smaller (less vertices) than the mesh</li>
<li>Have an implicit sense of topology (e.g. "this node is distal to that node")</li>
</ol>

<p>Extracting skeletons from meshes (or other types of data such as voxels) is
non-trivial and there are a great many research papers exploring various
different approaches (see <a href="https://scholar.google.com/scholar
?hl=en&amp;as_sdt=0%2C5&amp;q=skeleton+extraction&amp;btnG=">Google scholar</a>).</p>

<p><code><a href="">skeletor</a></code> implements some algorithms that I found useful in my work with
neurons. In my experience there is unfortuntely no magic bullet when it
comes to skeletonization and chances are you will have to fiddle around a bit
to get decent results.</p>

<h1 id="installation">Installation</h1>

<p>From PyPI:</p>

<div class="codehilite"><pre><span></span><code>pip3 install skeletor
</code></pre></div>

<p>For the bleeding-edge version from Github:</p>

<div class="codehilite"><pre><span></span><code>pip3 install git+git://github.com/schlegelp/skeletor@master
</code></pre></div>

<h1 id="getting-started">Getting started</h1>

<p>A skeletonization pipeline typically consists of:</p>

<ol>
<li>Some pre-processing of the mesh (e.g. fixing some potential errors like
degenerate faces, unreferenced vertices, etc.)</li>
<li>The skeletonization itself</li>
<li>Some post-processing of the skeleton (e.g. adding radius information)</li>
</ol>

<hr />

<p>Here is a complete list of available functions:</p>

<table>
<thead>
<tr>
  <th>function</th>
  <th>description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>example data</strong></td>
  <td></td>
</tr>
<tr>
  <td><code><a href="#example_mesh">skeletor.example_mesh()</a></code></td>
  <td>load an example mesh</td>
</tr>
<tr>
  <td><strong>pre-processing</strong></td>
  <td></td>
</tr>
<tr>
  <td><code><a href="#pre.fix_mesh">skeletor.pre.fix_mesh()</a></code></td>
  <td>fix some common errors found in meshes</td>
</tr>
<tr>
  <td><code><a href="#pre.remesh">skeletor.pre.remesh()</a></code></td>
  <td>re-generate mesh (uses Blender 3D)</td>
</tr>
<tr>
  <td><code><a href="#pre.simplify">skeletor.pre.simplify()</a></code></td>
  <td>reduce mesh complexity (uses Blender 3D)</td>
</tr>
<tr>
  <td><code><a href="#pre.contract">skeletor.pre.contract()</a></code></td>
  <td>contract mesh to facilitate skeletonization [1]</td>
</tr>
<tr>
  <td><strong>skeletonization</strong></td>
  <td></td>
</tr>
<tr>
  <td><code><a href="#skeletonize.by_wavefront">skeletor.skeletonize.by_wavefront()</a></code></td>
  <td>very fast, works well for tubular meshes (like neurons)</td>
</tr>
<tr>
  <td><code><a href="#skeletonize.by_vertex_clusters">skeletor.skeletonize.by_vertex_clusters()</a></code></td>
  <td>very fast but needs mesh to be contracted (see above)</td>
</tr>
<tr>
  <td><code><a href="#skeletonize.by_edge_collapse">skeletor.skeletonize.by_edge_collapse()</a></code></td>
  <td>presented in [1] but never got this to work well</td>
</tr>
<tr>
  <td><code><a href="#skeletonize.by_teasar">skeletor.skeletonize.by_teasar()</a></code></td>
  <td>very fast and robust, works on mesh surface</td>
</tr>
<tr>
  <td><code><a href="#skeletonize.by_tangent_ball">skeletor.skeletonize.by_tangent_ball()</a></code></td>
  <td>very fast, best on smooth meshes</td>
</tr>
<tr>
  <td><strong>postprocessing</strong></td>
  <td></td>
</tr>
<tr>
  <td><code><a href="#post.clean_up">skeletor.post.clean_up()</a></code></td>
  <td>fix some potential errors in the skeleton</td>
</tr>
<tr>
  <td><code><a href="#post.radii">skeletor.post.radii()</a></code></td>
  <td>add radius information using various method</td>
</tr>
</tbody>
</table>

<hr />

<p>See docstrings of the respective functions for details.</p>

<p>A pipeline might look like this:</p>

<ol>
<li><code><a href="#pre.fix_mesh">skeletor.pre.fix_mesh()</a></code> to fix the mesh</li>
<li><code><a href="#pre.simplify">skeletor.pre.simplify()</a></code> to simplify the mesh</li>
<li><code><a href="#pre.contract">skeletor.pre.contract()</a></code> to contract the mesh [1]</li>
<li><code><a href="#skeletonize.vertex_clusters">skeletor.skeletonize.vertex_clusters()</a></code> to generate a skeleton</li>
<li><code><a href="#post.clean_up">skeletor.post.clean_up()</a></code> to clean up some potential issues with the skeleton</li>
<li><code><a href="#post.radii">skeletor.post.radii()</a></code> to extract radii either by k-nearest neighbours or ray-casting</li>
</ol>

<p>In my experience there is no one-size-fits-all. You will have to play around to
find the right approach and parameters to get nice skeletons for your meshes.
If you need help just open an <a href="https://github.com/schlegelp/skeletor/issues">issue</a>.</p>

<p>Also check out the Gotchas below!</p>

<h1 id="examples">Examples</h1>

<p>First load the example mesh (a fruit fly neuron):</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mesh</span>
<span class="o">&lt;</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">6582</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">13772</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">&gt;</span>
</code></pre></div>

<p>Next see if there is stuff to fix in the mesh (degenerate faces, duplicate
vertices, etc.):</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fixed</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">fix_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">remove_disconnected</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fixed</span>
<span class="o">&lt;</span><span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">6213</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">faces</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">12805</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">&gt;</span>
</code></pre></div>

<p>Now for tubular meshes like this neuron, the "wave front" skeletonization method
performs really well: it works by casting waves across the mesh and collapsing
the resulting rings into a skeleton (kinda like when you throw a stone in a
pond and track the expanding ripples).</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="o">.</span><span class="n">by_wavefront</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">waves</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span>
<span class="o">&lt;</span><span class="n">Skeleton</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">(</span><span class="mi">1258</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">edges</span><span class="o">=</span><span class="p">(</span><span class="mi">1194</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">wavefront</span><span class="p">)</span><span class="o">&gt;</span>
</code></pre></div>

<p>All skeletonization methods return a <code><a href="#Skeleton">Skeleton</a></code> object. These are just
convenient objects to bundle the various outputs of the skeletonization.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="c1"># x/y/z location of skeleton vertices (nodes)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">vertices</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">16744</span><span class="p">,</span> <span class="mi">36720</span><span class="p">,</span> <span class="mi">26407</span><span class="p">],</span>
       <span class="o">...</span><span class="p">,</span>
       <span class="p">[</span><span class="mi">22076</span><span class="p">,</span> <span class="mi">23217</span><span class="p">,</span> <span class="mi">24472</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># child -&gt; parent edges</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">edges</span>
<span class="n">array</span><span class="p">([[</span>  <span class="mi">64</span><span class="p">,</span>   <span class="mi">31</span><span class="p">],</span>
       <span class="o">...</span><span class="p">,</span>
       <span class="p">[</span><span class="mi">1257</span><span class="p">,</span> <span class="mi">1252</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Mapping for mesh to skeleton vertex indices</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">mesh_map</span>
<span class="n">array</span><span class="p">([</span> <span class="mi">157</span><span class="p">,</span>  <span class="mi">158</span><span class="p">,</span> <span class="mi">1062</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span>  <span class="mi">525</span><span class="p">,</span>  <span class="mi">474</span><span class="p">,</span>  <span class="mi">547</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># SWC table</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
   <span class="n">node_id</span>  <span class="n">parent_id</span>             <span class="n">x</span>             <span class="n">y</span>             <span class="n">z</span>    <span class="n">radius</span>
<span class="mi">0</span>        <span class="mi">0</span>         <span class="o">-</span><span class="mi">1</span>  <span class="mf">16744.005859</span>  <span class="mf">36720.058594</span>  <span class="mf">26407.902344</span>  <span class="mf">0.000000</span>
<span class="mi">1</span>        <span class="mi">1</span>         <span class="o">-</span><span class="mi">1</span>   <span class="mf">5602.751953</span>  <span class="mf">22266.756510</span>  <span class="mf">15799.991211</span>  <span class="mf">7.542587</span>
<span class="mi">2</span>        <span class="mi">2</span>         <span class="o">-</span><span class="mi">1</span>  <span class="mf">16442.666667</span>  <span class="mf">14999.978516</span>  <span class="mf">10887.916016</span>  <span class="mf">5.333333</span>
</code></pre></div>

<p>SWC is a commonly used format for saving skeletons. <code><a href="#Skeleton">Skeleton</a></code> objects
have a method for quickly saving a correctly formatted SWC file:</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">save_swc</span><span class="p">(</span><span class="s1">&#39;~/Documents/my_skeleton.swc&#39;</span><span class="p">)</span>
</code></pre></div>

<p>If you installed <code>pyglet</code> (see above) you can also use <code>trimesh</code>'s plotting
capabilities to inspect the results:</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<p><img src="https://github.com/schlegelp/skeletor/raw/master/_static/example1.png" alt="skeletor_example" width="100%"/></p>

<p>That looks pretty good already but let's run some pro-forma postprocessing.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">sk</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">clean_up</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Skeleton</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="p">(</span><span class="mi">1071</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">edges</span><span class="o">=</span><span class="p">(</span><span class="mi">1070</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">&gt;</span>
</code></pre></div>

<p>So that would be a full pipeline mesh to skeleton. Don't expect your own meshes
to produce such nice results off the bat though. Chances are you will need to
play around to find the right recipe. If you don't know where to start, I suggest
you try out mesh contraction + vertex clustering first:</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fixed</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">fix_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">remove_disconnected</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Contract mesh to 10% (0.1) of original volume</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">cont</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">pre</span><span class="o">.</span><span class="n">contract</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Skeletonize</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">skeletonize</span><span class="o">.</span><span class="n">by_vertex_clusters</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">sampling_dist</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Replace contracted mesh with original for postprocessing and plotting</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">fixed</span>
<span class="o">&gt;&gt;&gt;</span> <span class="c1"># Add radii (vertex cluster method does not do that automatically)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">sk</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">radii</span><span class="p">(</span><span class="n">skel</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;knn&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">skel</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<h1 id="gotchas">Gotchas</h1>

<ul>
<li>while this is a general purpose library, my personal focus is on neurons and
this has certainly influenced things like default parameter values and certain
post-processing steps</li>
<li>meshes need to be triangular (we are using <code>trimesh</code>)</li>
<li>use <code>sk.pre.simplify</code> if your mesh is very complex (half a million vertices is
where things start getting sluggish)</li>
<li>a good mesh contraction is often half the battle</li>
<li>if the mesh consists of multiple disconnected pieces the skeleton will
likewise be fragmented (i.e. will have multiple roots)</li>
</ul>

<h1 id="benchmarks">Benchmarks</h1>

<p><img src="https://github.com/schlegelp/skeletor/raw/master/benchmarks/benchmark_2.png" alt="skeletor_benchmark" width="100%"/></p>

<p><a href="https://github.com/schlegelp/skeletor/blob/master/benchmarks/skeletor_benchmark.ipynb">Benchmarks</a>
were run on a 2018 MacBook Pro (2.2 GHz Core i7, 32Gb memory) with optional
<code>fastremap</code> dependency installed. Note some of these functions (e.g.
contraction and TEASAR/vertex cluster skeletonization) vary a lot in
speed based on parameterization.</p>

<h1 id="what-about-algorithm-x">What about algorithm <code>X</code>?</h1>

<p><code><a href="">skeletor</a></code> contains some algorithms that I found easy enough to implement
and useful for my work with neurons. If you have some interesting paper/approach
that could make a nice addition to <code><a href="">skeletor</a></code>, please get in touch on Github.
Pull requests are always welcome!</p>

<h1 id="references">References</h1>

<p><code>[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.</code></p>

<p>The abstract and the paper can be found <a href="http://visgraph.cse.ust.hk/projects/skeleton/">here</a>.
Also see <a href="https://www.youtube.com/watch?v=-H7n59YQCRM&amp;feature=youtu.be">this</a> YouTube video.</p>

<p>Some of the code in skeletor was modified from the
<a href="https://github.com/aalavandhaann/Py_BL_MeshSkeletonization">Py_BL_MeshSkeletonization</a>
addon created by #0K Srinivasan Ramachandran and published under GPL3.</p>

<h1 id="top-level-functions-and-classes">Top-level functions and classes</h1>

<p>At top-level we only expose <code><a href="#example_mesh">example_mesh()</a></code> and the <code><a href="#Skeleton">Skeleton</a></code> class (which
you probably won't ever need to touch manually). Everything else is neatly
tucked away into submodules (see side-bar or above table).</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1">#    This script is part of skeletonizer (http://www.github.com/schlegelp/skeletonizer).</span>
<span class="c1">#    Copyright (C) 2018 Philipp Schlegel</span>
<span class="c1">#    Modified from https://github.com/aalavandhaann/Py_BL_MeshSkeletonization</span>
<span class="c1">#    by #0K Srinivasan Ramachandran.</span>
<span class="c1">#</span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#    (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#    GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#    You should have received a copy of the GNU General Public License</span>
<span class="c1">#    along with this program.</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># What is skeletor?</span>

<span class="sd">Unlike its [namesake](https://en.wikipedia.org/wiki/Skeletor), this `skeletor`</span>
<span class="sd">does not (yet) seek to conquer Eternia but to turn meshes into skeletons.</span>

<span class="sd">Before we get started some terminology:</span>

<span class="sd">- a *mesh* is something that consists of *vertices* and *faces*</span>
<span class="sd">- a *skeleton* is a (hierarchical) tree-like structure consisting of *vertices*</span>
<span class="sd">  (also called *nodes*) and *edges* that connect them</span>

<span class="sd">Skeletons are useful for a range of reasons. For example:</span>

<span class="sd">1. Typically smaller (less vertices) than the mesh</span>
<span class="sd">2. Have an implicit sense of topology (e.g. &quot;this node is distal to that node&quot;)</span>

<span class="sd">Extracting skeletons from meshes (or other types of data such as voxels) is</span>
<span class="sd">non-trivial and there are a great many research papers exploring various</span>
<span class="sd">different approaches (see [Google scholar](https://scholar.google.com/scholar</span>
<span class="sd">?hl=en&amp;as_sdt=0%2C5&amp;q=skeleton+extraction&amp;btnG=)).</span>

<span class="sd">`skeletor` implements some algorithms that I found useful in my work with</span>
<span class="sd">neurons. In my experience there is unfortuntely no magic bullet when it</span>
<span class="sd">comes to skeletonization and chances are you will have to fiddle around a bit</span>
<span class="sd">to get decent results.</span>

<span class="sd"># Installation</span>

<span class="sd">From PyPI:</span>
<span class="sd">```bash</span>
<span class="sd">pip3 install skeletor</span>
<span class="sd">```</span>

<span class="sd">For the bleeding-edge version from Github:</span>
<span class="sd">```bash</span>
<span class="sd">pip3 install git+git://github.com/schlegelp/skeletor@master</span>
<span class="sd">```</span>

<span class="sd"># Getting started</span>

<span class="sd">A skeletonization pipeline typically consists of:</span>

<span class="sd">1. Some pre-processing of the mesh (e.g. fixing some potential errors like</span>
<span class="sd">   degenerate faces, unreferenced vertices, etc.)</span>
<span class="sd">2. The skeletonization itself</span>
<span class="sd">3. Some post-processing of the skeleton (e.g. adding radius information)</span>

<span class="sd">------</span>

<span class="sd">Here is a complete list of available functions:</span>

<span class="sd">| function                                    | description                                                 |</span>
<span class="sd">| ------------------------------------------- | ----------------------------------------------------------- |</span>
<span class="sd">| **example data**                            |                                                             |</span>
<span class="sd">| `skeletor.example_mesh()`                   | load an example mesh                                        |</span>
<span class="sd">| **pre-processing**                          |                                                             |</span>
<span class="sd">| `skeletor.pre.fix_mesh()`                   | fix some common errors found in meshes                      |</span>
<span class="sd">| `skeletor.pre.remesh()`                     | re-generate mesh (uses Blender 3D)                          |</span>
<span class="sd">| `skeletor.pre.simplify()`                   | reduce mesh complexity (uses Blender 3D)                    |</span>
<span class="sd">| `skeletor.pre.contract()`                   | contract mesh to facilitate skeletonization [1]             |</span>
<span class="sd">| **skeletonization**                         |                                                             |</span>
<span class="sd">| `skeletor.skeletonize.by_wavefront()`       | very fast, works well for tubular meshes (like neurons)     |</span>
<span class="sd">| `skeletor.skeletonize.by_vertex_clusters()` | very fast but needs mesh to be contracted (see above)       |</span>
<span class="sd">| `skeletor.skeletonize.by_edge_collapse()`   | presented in [1] but never got this to work well            |</span>
<span class="sd">| `skeletor.skeletonize.by_teasar()`          | very fast and robust, works on mesh surface                 |</span>
<span class="sd">| `skeletor.skeletonize.by_tangent_ball()`    | very fast, best on smooth meshes                            |</span>
<span class="sd">| **postprocessing**                          |                                                             |</span>
<span class="sd">| `skeletor.post.clean_up()`                  | fix some potential errors in the skeleton                   |</span>
<span class="sd">| `skeletor.post.radii()`                     | add radius information using various method                 |</span>

<span class="sd">------</span>

<span class="sd">See docstrings of the respective functions for details.</span>

<span class="sd">A pipeline might look like this:</span>

<span class="sd"> 1. `skeletor.pre.fix_mesh()` to fix the mesh</span>
<span class="sd"> 2. `skeletor.pre.simplify()` to simplify the mesh</span>
<span class="sd"> 3. `skeletor.pre.contract()` to contract the mesh [1]</span>
<span class="sd"> 4. `skeletor.skeletonize.vertex_clusters()` to generate a skeleton</span>
<span class="sd"> 5. `skeletor.post.clean_up()` to clean up some potential issues with the skeleton</span>
<span class="sd"> 6. `skeletor.post.radii()` to extract radii either by k-nearest neighbours or ray-casting</span>

<span class="sd">In my experience there is no one-size-fits-all. You will have to play around to</span>
<span class="sd">find the right approach and parameters to get nice skeletons for your meshes.</span>
<span class="sd">If you need help just open an [issue](https://github.com/schlegelp/skeletor/issues).</span>

<span class="sd">Also check out the Gotchas below!</span>

<span class="sd"># Examples</span>

<span class="sd">First load the example mesh (a fruit fly neuron):</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; import skeletor as sk</span>
<span class="sd">&gt;&gt;&gt; mesh = sk.example_mesh()</span>
<span class="sd">&gt;&gt;&gt; mesh</span>
<span class="sd">&lt;trimesh.Trimesh(vertices.shape=(6582, 3), faces.shape=(13772, 3))&gt;</span>
<span class="sd">```</span>

<span class="sd">Next see if there is stuff to fix in the mesh (degenerate faces, duplicate</span>
<span class="sd">vertices, etc.):</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; fixed = sk.pre.fix_mesh(mesh, remove_disconnected=5, inplace=False)</span>
<span class="sd">&gt;&gt;&gt; fixed</span>
<span class="sd">&lt;trimesh.Trimesh(vertices.shape=(6213, 3), faces.shape=(12805, 3))&gt;</span>
<span class="sd">```</span>

<span class="sd">Now for tubular meshes like this neuron, the &quot;wave front&quot; skeletonization method</span>
<span class="sd">performs really well: it works by casting waves across the mesh and collapsing</span>
<span class="sd">the resulting rings into a skeleton (kinda like when you throw a stone in a</span>
<span class="sd">pond and track the expanding ripples).</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; skel = sk.skeletonize.by_wavefront(fixed, waves=1, step_size=1)</span>
<span class="sd">&gt;&gt;&gt; skel</span>
<span class="sd">&lt;Skeleton(vertices=(1258, 3), edges=(1194, 2), method=wavefront)&gt;</span>
<span class="sd">```</span>

<span class="sd">All skeletonization methods return a `Skeleton` object. These are just</span>
<span class="sd">convenient objects to bundle the various outputs of the skeletonization.</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; # x/y/z location of skeleton vertices (nodes)</span>
<span class="sd">&gt;&gt;&gt; skel.vertices</span>
<span class="sd">array([[16744, 36720, 26407],</span>
<span class="sd">       ...,</span>
<span class="sd">       [22076, 23217, 24472]])</span>
<span class="sd">&gt;&gt;&gt; # child -&gt; parent edges</span>
<span class="sd">&gt;&gt;&gt; skel.edges</span>
<span class="sd">array([[  64,   31],</span>
<span class="sd">       ...,</span>
<span class="sd">       [1257, 1252]])</span>
<span class="sd">&gt;&gt;&gt; # Mapping for mesh to skeleton vertex indices</span>
<span class="sd">&gt;&gt;&gt; skel.mesh_map</span>
<span class="sd">array([ 157,  158, 1062, ...,  525,  474,  547])</span>
<span class="sd">&gt;&gt;&gt; # SWC table</span>
<span class="sd">&gt;&gt;&gt; skel.swc.head()</span>
<span class="sd">   node_id  parent_id             x             y             z    radius</span>
<span class="sd">0        0         -1  16744.005859  36720.058594  26407.902344  0.000000</span>
<span class="sd">1        1         -1   5602.751953  22266.756510  15799.991211  7.542587</span>
<span class="sd">2        2         -1  16442.666667  14999.978516  10887.916016  5.333333</span>
<span class="sd">```</span>

<span class="sd">SWC is a commonly used format for saving skeletons. `Skeleton` objects</span>
<span class="sd">have a method for quickly saving a correctly formatted SWC file:</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; skel.save_swc(&#39;~/Documents/my_skeleton.swc&#39;)</span>
<span class="sd">```</span>

<span class="sd">If you installed `pyglet` (see above) you can also use `trimesh`&#39;s plotting</span>
<span class="sd">capabilities to inspect the results:</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; skel.show(mesh=True)</span>
<span class="sd">```</span>

<span class="sd">&lt;img src=&quot;https://github.com/schlegelp/skeletor/raw/master/_static/example1.png&quot; alt=&quot;skeletor_example&quot; width=&quot;100%&quot;/&gt;</span>

<span class="sd">That looks pretty good already but let&#39;s run some pro-forma postprocessing.</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; sk.post.clean_up(skel, inplace=True)</span>
<span class="sd">&lt;Skeleton(vertices=(1071, 3), edges=(1070, 2))&gt;</span>
<span class="sd">```</span>

<span class="sd">So that would be a full pipeline mesh to skeleton. Don&#39;t expect your own meshes</span>
<span class="sd">to produce such nice results off the bat though. Chances are you will need to</span>
<span class="sd">play around to find the right recipe. If you don&#39;t know where to start, I suggest</span>
<span class="sd">you try out mesh contraction + vertex clustering first:</span>

<span class="sd">```Python</span>
<span class="sd">&gt;&gt;&gt; import skeletor as sk</span>
<span class="sd">&gt;&gt;&gt; mesh = sk.example_mesh()</span>
<span class="sd">&gt;&gt;&gt; fixed = sk.pre.fix_mesh(mesh, remove_disconnected=5, inplace=False)</span>
<span class="sd">&gt;&gt;&gt; # Contract mesh to 10% (0.1) of original volume</span>
<span class="sd">&gt;&gt;&gt; cont = sk.pre.contract(fixed, epsilon=0.1)</span>
<span class="sd">&gt;&gt;&gt; # Skeletonize</span>
<span class="sd">&gt;&gt;&gt; skel = sk.skeletonize.by_vertex_clusters(cont, sampling_dist=100)</span>
<span class="sd">&gt;&gt;&gt; # Replace contracted mesh with original for postprocessing and plotting</span>
<span class="sd">&gt;&gt;&gt; skel.mesh = fixed</span>
<span class="sd">&gt;&gt;&gt; # Add radii (vertex cluster method does not do that automatically)</span>
<span class="sd">&gt;&gt;&gt; sk.post.radii(skel, method=&#39;knn&#39;)</span>
<span class="sd">&gt;&gt;&gt; skel.show(mesh=True)</span>
<span class="sd">```</span>

<span class="sd"># Gotchas</span>

<span class="sd">- while this is a general purpose library, my personal focus is on neurons and</span>
<span class="sd">  this has certainly influenced things like default parameter values and certain</span>
<span class="sd">  post-processing steps</span>
<span class="sd">- meshes need to be triangular (we are using `trimesh`)</span>
<span class="sd">- use `sk.pre.simplify` if your mesh is very complex (half a million vertices is</span>
<span class="sd">  where things start getting sluggish)</span>
<span class="sd">- a good mesh contraction is often half the battle</span>
<span class="sd">- if the mesh consists of multiple disconnected pieces the skeleton will</span>
<span class="sd">  likewise be fragmented (i.e. will have multiple roots)</span>

<span class="sd"># Benchmarks</span>

<span class="sd">&lt;img src=&quot;https://github.com/schlegelp/skeletor/raw/master/benchmarks/benchmark_2.png&quot; alt=&quot;skeletor_benchmark&quot; width=&quot;100%&quot;/&gt;</span>

<span class="sd">[Benchmarks](https://github.com/schlegelp/skeletor/blob/master/benchmarks/skeletor_benchmark.ipynb)</span>
<span class="sd">were run on a 2018 MacBook Pro (2.2 GHz Core i7, 32Gb memory) with optional</span>
<span class="sd">`fastremap` dependency installed. Note some of these functions (e.g.</span>
<span class="sd">contraction and TEASAR/vertex cluster skeletonization) vary a lot in</span>
<span class="sd">speed based on parameterization.</span>

<span class="sd"># What about algorithm `X`?</span>

<span class="sd">`skeletor` contains some algorithms that I found easy enough to implement</span>
<span class="sd">and useful for my work with neurons. If you have some interesting paper/approach</span>
<span class="sd">that could make a nice addition to `skeletor`, please get in touch on Github.</span>
<span class="sd">Pull requests are always welcome!</span>

<span class="sd"># References</span>

<span class="sd">`[1] Au OK, Tai CL, Chu HK, Cohen-Or D, Lee TY. Skeleton extraction by mesh contraction. ACM Transactions on Graphics (TOG). 2008 Aug 1;27(3):44.`</span>

<span class="sd">The abstract and the paper can be found [here](http://visgraph.cse.ust.hk/projects/skeleton/).</span>
<span class="sd">Also see [this](https://www.youtube.com/watch?v=-H7n59YQCRM&amp;feature=youtu.be) YouTube video.</span>

<span class="sd">Some of the code in skeletor was modified from the</span>
<span class="sd">[Py_BL_MeshSkeletonization](https://github.com/aalavandhaann/Py_BL_MeshSkeletonization)</span>
<span class="sd">addon created by #0K Srinivasan Ramachandran and published under GPL3.</span>

<span class="sd"># Top-level functions and classes</span>
<span class="sd">At top-level we only expose `example_mesh()` and the `Skeleton` class (which</span>
<span class="sd">you probably won&#39;t ever need to touch manually). Everything else is neatly</span>
<span class="sd">tucked away into submodules (see side-bar or above table).</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.1.0&quot;</span>
<span class="n">__version_vector__</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">skeletonize</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">pre</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">post</span>

<span class="kn">from</span> <span class="nn">.skeletonize.base</span> <span class="kn">import</span> <span class="n">Skeleton</span>
<span class="kn">from</span> <span class="nn">.data</span> <span class="kn">import</span> <span class="n">example_mesh</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;numpy&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Skeleton&#39;</span><span class="p">,</span> <span class="s1">&#39;example_mesh&#39;</span><span class="p">]</span>
</pre></div>

        </details>

            </section>
                <section id="Skeleton">
                                <div class="attr class">
        <a class="headerlink" href="#Skeleton">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Skeleton</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Skeleton</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class representing a skeleton.</span>

<span class="sd">    Typically returned as results from a skeletonization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    swc :       pd.DataFrame, optional</span>
<span class="sd">                SWC table.</span>
<span class="sd">    vertices :  (N, 3) array</span>
<span class="sd">                Vertex (node) positions.</span>
<span class="sd">    edges :     (M, 2) array</span>
<span class="sd">                Indices of connected vertex pairs.</span>
<span class="sd">    radii :     (N, ) array, optional</span>
<span class="sd">                Radii for each vertex (node) in the skeleton.</span>
<span class="sd">    mesh :      trimesh, optional</span>
<span class="sd">                The original mesh.</span>
<span class="sd">    mesh_map :  array, optional</span>
<span class="sd">                Same length as ``mesh``. Maps mesh vertices to vertices (nodes)</span>
<span class="sd">                in the skeleton.</span>
<span class="sd">    skel_map :  array of arrays, optional</span>
<span class="sd">                Inverse of `mesh_map`: maps skeleton vertices (nodes) to mesh</span>
<span class="sd">                vertices.</span>
<span class="sd">    method :    str, optional</span>
<span class="sd">                Which method was used to generate the skeleton.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swc</span> <span class="o">=</span> <span class="n">swc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span> <span class="o">=</span> <span class="n">mesh_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Summary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return quick summary of the skeleton&#39;s geometry.&quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;vertices&#39;</span><span class="p">):</span>
            <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;vertices=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;edges&#39;</span><span class="p">):</span>
            <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;edges=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">):</span>
            <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;method=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;Skeleton(</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span><span class="si">}</span><span class="s1">)&gt;&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return skeleton edges.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">parent_id</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;parent_id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return skeleton vertices (nodes).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="p">[[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return radii.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;radius&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No radius info found. Run `skeletor.post.radii()`&#39;</span>
                             <span class="s1">&#39; to get them.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skeleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Skeleton as trimesh Path3D.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_skeleton&#39;</span><span class="p">):</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">tm</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">entities</span><span class="o">.</span><span class="n">Line</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">Path3D</span><span class="p">(</span><span class="n">entities</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span>
                                            <span class="n">vertices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span>
                                            <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skeleton</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">skel_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Skeleton vertex (nodes) to mesh vertices. Based on `mesh_map`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span>
                            <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">False</span>
                                          <span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span>
                                                                      <span class="p">)</span><span class="o">.</span><span class="n">values</span>

    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean up skeleton.&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Re-index to make node IDs continous again</span>
        <span class="n">x</span><span class="o">.</span><span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">reindex_swc</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">swc</span><span class="p">)</span>

        <span class="c1"># Update mesh map</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
            <span class="n">x</span><span class="o">.</span><span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy of the skeleton.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">mesh_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">save_swc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save skeleton in SWC format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath :      path-like</span>
<span class="sd">                        Filepath to save SWC to.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        # SWC format file</span>
<span class="s2">        # based on specifications at http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html</span>
<span class="s2">        # Created on </span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="si">}</span><span class="s2"> using skeletor (https://github.com/schlegelp/skeletor)</span>
<span class="s2">        # PointNo Label X Y Z Radius Parent</span>
<span class="s2">        # Labels:</span>
<span class="s2">        # 0 = undefined, 1 = soma, 5 = fork point, 6 = end point</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Make copy of SWC table</span>
        <span class="n">swc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Set all labels to undefined</span>
        <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">swc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">swc</span><span class="o">.</span><span class="n">parent_id</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="n">n_childs</span> <span class="o">=</span> <span class="n">swc</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;parent_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">n_childs</span><span class="p">[</span><span class="n">n_childs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">swc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="c1"># Add radius if missing</span>
        <span class="k">if</span> <span class="s1">&#39;radius&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">swc</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Get things in order</span>
        <span class="n">swc</span> <span class="o">=</span> <span class="n">swc</span><span class="p">[[</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="s1">&#39;parent_id&#39;</span><span class="p">]]</span>

        <span class="c1"># Adjust column titles</span>
        <span class="n">swc</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PointNo&#39;</span><span class="p">,</span> <span class="s1">&#39;Label&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Radius&#39;</span><span class="p">,</span> <span class="s1">&#39;Parent&#39;</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="c1"># Write header</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

            <span class="c1"># Write data</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">swc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">scene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a Scene object containing the skeleton.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scene :     trimesh.scene.scene.Scene</span>
<span class="sd">                    Contains the skeleton and optionally the mesh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Skeleton has no mesh.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">face_colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>

            <span class="c1"># Note the copy(): without it the transform in show() changes</span>
            <span class="c1"># the original meshes</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">Scene</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">copy</span><span class="p">()],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">Scene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sc</span>

    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Render the skeleton in an opengl window. Requires pyglet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh :      bool</span>
<span class="sd">                    If True, will render transparent mesh on top of the</span>
<span class="sd">                    skeleton.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        scene :     trimesh.scene.Scene</span>
<span class="sd">                    Scene with skeleton in it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># I encountered some issues if object space is big and the easiest</span>
        <span class="c1"># way to work around this is to apply a transform such that the</span>
        <span class="c1"># coordinates have -5 to +5 bounds</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">scene</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">fac</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">scene</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Class representing a skeleton.</p>

<p>Typically returned as results from a skeletonization.</p>

<h6 id="attributes">Attributes</h6>

<ul>
<li><strong>swc</strong> (pd.DataFrame, optional):
SWC table.</li>
<li><strong>vertices</strong> ((N, 3) array):
Vertex (node) positions.</li>
<li><strong>edges</strong> ((M, 2) array):
Indices of connected vertex pairs.</li>
<li><strong>radii</strong> ((N, ) array, optional):
Radii for each vertex (node) in the skeleton.</li>
<li><strong>mesh</strong> (trimesh, optional):
The original mesh.</li>
<li><strong>mesh_map</strong> (array, optional):
Same length as <code>mesh</code>. Maps mesh vertices to vertices (nodes)
in the skeleton.</li>
<li><strong>skel_map</strong> (array of arrays, optional):
Inverse of <code>mesh_map</code>: maps skeleton vertices (nodes) to mesh
vertices.</li>
<li><strong>method</strong> (str, optional):
Which method was used to generate the skeleton.</li>
</ul>
</div>


                            <div id="Skeleton.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Skeleton.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Skeleton</span><span class="signature">(swc, mesh=None, mesh_map=None, method=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">swc</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swc</span> <span class="o">=</span> <span class="n">swc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span> <span class="o">=</span> <span class="n">mesh_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Skeleton.edges" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Skeleton.edges">#&nbsp;&nbsp</a>

        <span class="name">edges</span>
    </div>

            <div class="docstring"><p>Return skeleton edges.</p>
</div>


                            </div>
                            <div id="Skeleton.vertices" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Skeleton.vertices">#&nbsp;&nbsp</a>

        <span class="name">vertices</span>
    </div>

            <div class="docstring"><p>Return skeleton vertices (nodes).</p>
</div>


                            </div>
                            <div id="Skeleton.radius" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Skeleton.radius">#&nbsp;&nbsp</a>

        <span class="name">radius</span>
    </div>

            <div class="docstring"><p>Return radii.</p>
</div>


                            </div>
                            <div id="Skeleton.skeleton" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Skeleton.skeleton">#&nbsp;&nbsp</a>

        <span class="name">skeleton</span>
    </div>

            <div class="docstring"><p>Skeleton as trimesh Path3D.</p>
</div>


                            </div>
                            <div id="Skeleton.skel_map" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Skeleton.skel_map">#&nbsp;&nbsp</a>

        <span class="name">skel_map</span>
    </div>

            <div class="docstring"><p>Skeleton vertex (nodes) to mesh vertices. Based on <code>mesh_map</code>.</p>
</div>


                            </div>
                            <div id="Skeleton.reindex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Skeleton.reindex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">reindex</span><span class="signature">(self, inplace=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clean up skeleton.&quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Re-index to make node IDs continous again</span>
        <span class="n">x</span><span class="o">.</span><span class="n">swc</span><span class="p">,</span> <span class="n">new_ids</span> <span class="o">=</span> <span class="n">reindex_swc</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">swc</span><span class="p">)</span>

        <span class="c1"># Update mesh map</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
            <span class="n">x</span><span class="o">.</span><span class="n">mesh_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_ids</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
</pre></div>

        </details>

            <div class="docstring"><p>Clean up skeleton.</p>
</div>


                            </div>
                            <div id="Skeleton.copy" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Skeleton.copy">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">copy</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy of the skeleton.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Skeleton</span><span class="p">(</span><span class="n">swc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">mesh_map</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_map</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return copy of the skeleton.</p>
</div>


                            </div>
                            <div id="Skeleton.save_swc" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Skeleton.save_swc">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">save_swc</span><span class="signature">(self, filepath)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">save_swc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save skeleton in SWC format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath :      path-like</span>
<span class="sd">                        Filepath to save SWC to.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">        # SWC format file</span>
<span class="s2">        # based on specifications at http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html</span>
<span class="s2">        # Created on </span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">today</span><span class="p">()</span><span class="si">}</span><span class="s2"> using skeletor (https://github.com/schlegelp/skeletor)</span>
<span class="s2">        # PointNo Label X Y Z Radius Parent</span>
<span class="s2">        # Labels:</span>
<span class="s2">        # 0 = undefined, 1 = soma, 5 = fork point, 6 = end point</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Make copy of SWC table</span>
        <span class="n">swc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">swc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Set all labels to undefined</span>
        <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">swc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">swc</span><span class="o">.</span><span class="n">parent_id</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="n">n_childs</span> <span class="o">=</span> <span class="n">swc</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;parent_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">n_childs</span><span class="p">[</span><span class="n">n_childs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">swc</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">swc</span><span class="o">.</span><span class="n">node_id</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="c1"># Add radius if missing</span>
        <span class="k">if</span> <span class="s1">&#39;radius&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">swc</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">swc</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Get things in order</span>
        <span class="n">swc</span> <span class="o">=</span> <span class="n">swc</span><span class="p">[[</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="s1">&#39;parent_id&#39;</span><span class="p">]]</span>

        <span class="c1"># Adjust column titles</span>
        <span class="n">swc</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PointNo&#39;</span><span class="p">,</span> <span class="s1">&#39;Label&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;Radius&#39;</span><span class="p">,</span> <span class="s1">&#39;Parent&#39;</span><span class="p">]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="c1"># Write header</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

            <span class="c1"># Write data</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">writerows</span><span class="p">(</span><span class="n">swc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Save skeleton in SWC format.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>filepath</strong> (path-like):
Filepath to save SWC to.</li>
</ul>
</div>


                            </div>
                            <div id="Skeleton.scene" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Skeleton.scene">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">scene</span><span class="signature">(self, mesh=False, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">scene</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a Scene object containing the skeleton.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scene :     trimesh.scene.scene.Scene</span>
<span class="sd">                    Contains the skeleton and optionally the mesh.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Skeleton has no mesh.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">visual</span><span class="o">.</span><span class="n">face_colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>

            <span class="c1"># Note the copy(): without it the transform in show() changes</span>
            <span class="c1"># the original meshes</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">Scene</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">copy</span><span class="p">()],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">Scene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sc</span>
</pre></div>

        </details>

            <div class="docstring"><p>Return a Scene object containing the skeleton.</p>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>scene</strong> (trimesh.scene.scene.Scene):
Contains the skeleton and optionally the mesh.</li>
</ul>
</div>


                            </div>
                            <div id="Skeleton.show" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Skeleton.show">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">show</span><span class="signature">(self, mesh=False, **kwargs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Render the skeleton in an opengl window. Requires pyglet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh :      bool</span>
<span class="sd">                    If True, will render transparent mesh on top of the</span>
<span class="sd">                    skeleton.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        scene :     trimesh.scene.Scene</span>
<span class="sd">                    Scene with skeleton in it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># I encountered some issues if object space is big and the easiest</span>
        <span class="c1"># way to work around this is to apply a transform such that the</span>
        <span class="c1"># coordinates have -5 to +5 bounds</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">scene</span><span class="o">.</span><span class="n">apply_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">fac</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="n">fac</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">scene</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Render the skeleton in an opengl window. Requires pyglet.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>mesh</strong> (bool):
If True, will render transparent mesh on top of the
skeleton.</li>
</ul>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>scene</strong> (trimesh.scene.Scene):
Scene with skeleton in it.</li>
</ul>
</div>


                            </div>
                </section>
                <section id="example_mesh">
                            <div class="attr function"><a class="headerlink" href="#example_mesh">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">example_mesh</span><span class="signature">()</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">example_mesh</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Load and return example mesh.</span>

<span class="sd">    The example mesh is a fruit fly neuron (an olfactory projection neuron of</span>
<span class="sd">    the DA1 glomerulus) segmented from an EM image data set. It is part of the</span>
<span class="sd">    Janelia hemibrain data set (see [here](https://neuprint.janelia.org)) [1].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Louis K. Scheffer et al., eLife. 2020. doi: 10.7554/eLife.57443</span>
<span class="sd">    A connectome and analysis of the adult Drosophila central brain</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trimesh.Trimesh</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import skeletor as sk</span>
<span class="sd">    &gt;&gt;&gt; # Load this example mesh</span>
<span class="sd">    &gt;&gt;&gt; mesh = sk.example_mesh()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">tm</span><span class="o">.</span><span class="n">load_mesh</span><span class="p">(</span><span class="n">obj_path</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Load and return example mesh.</p>

<p>The example mesh is a fruit fly neuron (an olfactory projection neuron of
the DA1 glomerulus) segmented from an EM image data set. It is part of the
Janelia hemibrain data set (see <a href="https://neuprint.janelia.org">here</a>) [1].</p>

<h6 id="references">References</h6>

<p>[1] Louis K. Scheffer et al., eLife. 2020. doi: 10.7554/eLife.57443
A connectome and analysis of the adult Drosophila central brain</p>

<h6 id="returns">Returns</h6>

<ul>
<li><strong>trimesh.Trimesh</strong></li>
</ul>

<h6 id="examples">Examples</h6>

<div class="codehilite"><pre><span></span><code><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">skeletor</span> <span class="k">as</span> <span class="nn">sk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Load this example mesh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">sk</span><span class="o">.</span><span class="n">example_mesh</span><span class="p">()</span>
</code></pre></div>
</div>


                </section>
    </main>
</body>
</html>